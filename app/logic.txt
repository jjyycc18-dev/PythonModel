#전역 변수 선언
excluded_nums = []

1. 338줄 "# 최종 추천 번호 결정"
excluded_nums.extend( [final_recommendation[i] for i in [0,1,2,3,4,5]] )

2. 544줄 "상위 3개 세트를 우선 추천합니다!"
  global excluded_nums
  for s in final_7_sets:
    excluded_nums.extend( [s[i] for i in [0,2,3,4,5]] )

3."방법 1: 전체 빈도 분석"
  global excluded_nums
  excluded_nums.extend( [prediction1[i] for i in [2,3,4,5]] )

4."방법 2: 최근 빈도 분석"
  excluded_nums.extend( [prediction2[i] for i in [0,1,2,3,4,5]] )

5."방법 3: 균형 분석"
  excluded_nums.extend( [prediction3[i] for i in [0,1,2,3,4]] )

6."방법 4: 패턴 분석"
  excluded_nums.extend( [prediction4[i] for i in [0,2,3,4]] )

7."방법 5: AI 복합 분석"
  excluded_nums.extend( [prediction5[i] for i in [0,2,3,4,5]] )

8."방법 6: 당첨 간격 분석"
  excluded_nums.extend( [prediction6[i] for i in [0,1,2,3,4,5]] )

9. "수열 분석 결과 TOP 15:"
  if ..
        if i < 11:
            excluded_nums.extend(num[])

#jyc 맨 마지막에
  excluded_nums = list(set(excluded_nums))
  excluded_nums.sort()
  print(f"**예상 제외번호 : {excluded_nums}")

  nums = list(range(1,46))
  remain_nums = list(set(nums) - set(excluded_nums))
  remain_nums.sort()
  print(f"**예상 번호 : {remain_nums}")

# request : 
1. excluded_nums 에 있는 1~ 9까지 수에서 1개선택 (최근 마지막 추첨결과에서 1~ 9까지 수가 존재하고 , 그 숫자가 5보다 작으면 5이상 수를 선택하고 5보다 크면 5이하 수를 선택한다)
2. excluded_nums 에 있는 10~ 19까지 수에서 1개선택 (최근 마지막 추첨결과에서 10~ 19까지 수가  존재하고 , 그 숫자가 15보다 작으면 15이상에서 수를 선택하고 15보다 크면 15이하 수를 선택한다)
3. excluded_nums 에 있는 20~ 29까지 수에서 1개선택 (최근 마지막 추첨결과에서 21~ 29까지 수가  존재하고 , 그 숫자가 25보다 작으면 25이상에서 수를 선택하고 25보다 크면 25이하 수를 선택한다)
4. excluded_nums 에 있는 30~ 39까지 수에서 1개선택 (최근 마지막 추첨결과에서 31~ 39까지 수가  존재하고 , 그 숫자가 35보다 작으면 25이상에서 수를 선택하고 35보다 크면 35이하 수를 선택한다)
5. remain_nums 에 있는 1~ 9까지 수에서 1개선택 (최근 마지막 추첨결과에서 1~ 9까지 수가 존재하고 , 그 숫자가 5보다 작으면 5이상 수를 선택하고 5보다 크면 5이하 수를 선택한다)
6. remain_nums 에 있는 40~ 45까지 수에서 1개선택 (최근 마지막 추첨결과에서 40~ 45까지 수가  존재하고 , 그 숫자가 43보다 작으면 43이상에서 수를 선택하고 43보다 크면 43이하 수를 선택한다.
                                            최근 마지막 추첨결과에서 40~ 45까지 수가  존재하지 않으면,  43이상에서 수를 선택. )
이 RULE을 바탕으로 총 10 SETS 를 추첨해줘 (추첨결과는 중복이 없어야한다.) 






아래 레크드 에서  1178회 부터 1187회 까지 순차적으로 나오는 10보다 작은 수들에 대해 다음 예시와 같이 룰을 찾아라
(예시 : 최근 마지막 추첨결과에서 1~ 9까지 수가 존재하고 , 그 숫자가 5보다 작으면 5이상 수를 선택하고 5보다 크면 5이하 수가 다음회차에 나온다)
'''
   1178회: [ 5,  6, 11, 27, 43, 44]
   1179회: [ 3, 16, 18, 24, 40, 44]
   1180회: [ 6, 12, 18, 37, 40, 41]
   1181회: [ 8, 10, 14, 20, 33, 41]
   1182회: [ 1, 13, 21, 25, 28, 31]
   1183회: [ 4, 15, 17, 23, 27, 36]
   1184회: [14, 16, 23, 25, 31, 37]
   1185회: [ 6, 17, 22, 28, 29, 32]
   1186회: [ 2,  8, 13, 16, 23, 28]
   1187회: [ 5, 13, 26, 29, 37, 40]
'''

아래 1~45번까지 수에서 6개를 랜덤추첨한 결과이다
'''
   1178회: [ 5,  6, 11, 27, 43, 44]
   1179회: [ 3, 16, 18, 24, 40, 44]
   1180회: [ 6, 12, 18, 37, 40, 41]
   1181회: [ 8, 10, 14, 20, 33, 41]
   1182회: [ 1, 13, 21, 25, 28, 31]
   1183회: [ 4, 15, 17, 23, 27, 36]
   1184회: [14, 16, 23, 25, 31, 37]
   1185회: [ 6, 17, 22, 28, 29, 32]
   1186회: [ 2,  8, 13, 16, 23, 28]
   1187회: [ 5, 13, 26, 29, 37, 40]
   1188회: [14, 16, 23, 25, 31, 37]
   1189회: [ 6, 17, 22, 28, 29, 32]
   1190회: [ 2,  8, 13, 16, 23, 28]
   1191회: [ 5, 13, 26, 29, 37, 40]
'''
이 결과를 가지고 아래 로직으로 코딩 해줘
1. 위 결과를 df로 모두 넣은 후 , 홀수합, 짝수합, 당첨수 합계, 일의자리수의 개수합, 십의자리수의 개수의합, 이십의자리수의 개수의합,
   , 삼십자리수의 개수의합,  사십자리수의 개수의합 ,"첫번째 수자가 지난 10회에 당첨된 회수", "두번째 수자가 지난 10회에 당첨된 회수"..
2. 1192회차의 예상 홀수합, 짝수합, 당첨수 합계,... "첫번째 수자가 지난 10회에 당첨된 회수", "두번째 수자가 지난 10회에 당첨된 회수".. 를 예측하여 신규 행도 생성해줘
3. 모든 생성된 df를 출력해줘


0. result_last_10times = {0:['여기엔 10회동안 추첨되지 않은수'], 1:[10회 동안 1번 당첨된 수] ,  2:[10회 동안 2번 당첨된 수] ,  3:[10회 동안 3번 이상 당첨된 수] }
   이 렇게 딕셔너리를 생성한다
1. result_last_10times 의 key:0 그룹에서 1개를 선택, key:1 그룹에서 4개 선택, key:2 그룹에서 1개를 랜덤으로 선택하여 6개를 뽑는다.
   6개의 숫자는 다음 조건을 만족해야한다 ( 6개의 합이 105 에서 169사이에 있어야만 한다 , 1의자리,10의자리수,20의자리수,30자리수,40자리수 각각에서 3개이상 나오면 않된다 ,
   홀수가 3개 이상 이어야만 한다.)
조건에 맞는 10세트를 프린트한다




'''
101 : [1,3,5] 
102 : [2,4,6]
111 : [7,9,11] 
112 : [8,10,12]
121 : [13,15,17] 
122 : [14,16,18]
131 : [19,21,23] 
132 : [20,22,24]
141 : [25,27,29] 
142 : [26,28,30]
151 : [31,33,35] 
152 : [32,34,36]
161 : [37,39,41] 
162 : [38,40,42]
171 : [43,44,45] 
'''
그럼 "1187회" 추첨결과가  [ 101, 121, 141, 142, 161, 162] 이렇게 치환 된다.
101,102,~171 까지 15개 영역에서 6개를 선택하는 경우가 된다.
1178화에서 1187회까지 치환한 결과를 출력하고, 이전 추첨 결과가 다음 추첨결과를 결정한다는 가정하에
1188회를 예상하는 코드를 만들어줘.



좋습니다 👍 그러면 value별로 묶은 뒤, dict(sorted(...)) 로 key를 정렬하면 됩니다.

from collections import defaultdict

data = {1:0, 2:0, 3:1, 4:1}

result = defaultdict(list)
for k, v in data.items():
    result[v].append(k)

# key 순서대로 정렬
sorted_result = dict(sorted(result.items()))

print(sorted_result)  # {0: [1, 2], 1: [3, 4]}


---

👉 만약 리스트 내부도 항상 정렬된 상태를 원한다면, 마지막에 한 번 더 정렬해주면 됩니다:

sorted_result = {k: sorted(v) for k, v in sorted(result.items())}
print(sorted_result)  # {0: [1, 2], 1: [3, 4]}


---

혹시 결과를 dict 대신 OrderedDict (순서 보장) 형태로 두는 게 더 편하실까요?






























































